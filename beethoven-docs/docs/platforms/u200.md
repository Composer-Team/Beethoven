---
id: u200
title: Xilinx U200 Platform
sidebar_label: U200
---

# Xilinx U200 Data Center Accelerator Card

The Xilinx Alveo U200 is a PCIe-based data center accelerator card featuring a 3-die Virtex UltraScale+ FPGA. Beethoven provides support for building and deploying accelerators on U200 boards.

:::note Platform Status
U200 support is available in the Beethoven codebase. Build flows and deployment scripts are platform-specific and may require customization for your environment.
:::

## Hardware Specifications

| Component | Specification |
|-----------|---------------|
| **FPGA** | Xilinx Virtex UltraScale+ |
| **Dies/SLRs** | 3 (SLR0, SLR1, SLR2) |
| **Memory** | 16GB DDR4 (discrete) |
| **Interface** | PCIe Gen3 x16 |
| **Clock Rate** | 300 MHz (default) |
| **Memory Bandwidth** | 512-bit AXI4 interface (64-byte beats) |

## Platform Configuration

The U200 platform is configured with the following characteristics:

```scala title="U200Platform configuration"
class U200Platform(implicit p: Parameters) extends Platform {
  override val platformType = FPGA

  // Memory Configuration
  override val hasDiscreteMemory = true
  override val physicalMemoryBytes = 16L * 1024 * 1024 * 1024  // 16GB
  override val memoryNChannels = 1
  override val memoryControllerBeatBytes = 64  // 512-bit interface

  // Clock Configuration
  override val clockRateMHz = 300

  // Multi-Die Topology
  override val physicalDevices = List(
    DeviceConfig(0, "pblock_SLR0"),
    DeviceConfig(1, "pblock_SLR1"),
    DeviceConfig(2, "pblock_SLR2")
  )

  override val physicalConnectivity = List((0,1), (1,2))

  // Front Bus (Host Interface)
  override val frontBusBeatBytes = 4  // 32-bit AXI-Lite
}
```

## Multi-Die Floorplanning

The U200's 3-die FPGA requires careful floorplanning for timing closure. Use Beethoven's floorplanning infrastructure to place modules across SLRs:

```scala title="U200 multi-SLR accelerator"
import beethoven._
import beethoven.Floorplanning._
import chipsalliance.rocketchip.config.Parameters

class U200Accelerator()(implicit p: Parameters) extends AcceleratorCore {
  // SLR0: Host interface
  val cmdInterface = BeethovenIO(
    new AccelCommand("process") {
      val input_addr = Address()
      val output_addr = Address()
      val length = UInt(32.W)
    },
    EmptyAccelResponse()
  )

  // SLR1: Memory controllers
  DeviceContext.withDevice(1) {
    val reader = getReaderModule("input_data")
    val writer = getWriterModule("output_data")
  }

  // SLR2: Compute array
  DeviceContext.withDevice(2) {
    val compute = LazyModuleWithFloorplan(
      new ComputeArray,
      2,
      "compute_array"
    )
  }
}
```

See the [Floorplanning Guide](/docs/hardware/floorplanning) for detailed multi-die optimization strategies.

## Building Your Accelerator

### Configuration

Create a build configuration targeting the U200 platform:

```scala title="U200 build configuration"
import beethoven._
import beethoven.Platforms._

object MyU200Build extends BeethovenBuild(
  new MyAcceleratorConfig,
  buildMode = BuildMode.Synthesis,
  platform = new U200Platform
)
```

### Running the Build

```bash
cd Beethoven-Hardware
export BEETHOVEN_PATH=`pwd`/../my-beethoven-output
sbt run
# Select MyU200Build from the menu
```

This generates:
- Verilog RTL in `$BEETHOVEN_PATH/build/hw/`
- C++ bindings in `$BEETHOVEN_PATH/build/beethoven_hardware.{h,cc}`
- Constraint files in `$BEETHOVEN_PATH/build/user_constraints.xdc`

### Synthesis with Vivado

The U200 build does not include a pre-packaged shell like AWS F2. You'll need to integrate the generated Verilog with Xilinx's U200 base design:

```tcl title="Vivado synthesis flow"
# Create project
create_project u200_accel ./u200_project -part xcu200-fsgd2104-2-e

# Add Beethoven-generated RTL
add_files $env(BEETHOVEN_PATH)/build/hw/*.v

# Add base U200 design files
# (Platform-specific - depends on your U200 development kit)

# Add constraints
add_files -fileset constrs_1 $env(BEETHOVEN_PATH)/build/user_constraints.xdc

# Run synthesis and implementation
launch_runs synth_1
wait_on_run synth_1
launch_runs impl_1 -to_step write_bitstream
wait_on_run impl_1
```

:::warning Custom Integration Required
Unlike AWS F2 with its pre-built shell, U200 builds require integration with Xilinx's base design or a custom shell. Consult your U200 development kit documentation for shell integration.
:::

## Memory Interface

The U200 platform provides a single 16GB DDR4 channel with 512-bit width:

```scala title="Memory channel configuration"
memoryChannelConfig = List(
  ReadChannelConfig("input_data", dataBytes = 64),    // 512-bit reads
  WriteChannelConfig("output_data", dataBytes = 64)   // 512-bit writes
)
```

Maximum theoretical bandwidth: **300 MHz Ã— 64 bytes = 19.2 GB/s**

:::tip Memory Performance
Use wide memory interfaces (64 bytes) to maximize bandwidth utilization. Narrower interfaces (4, 8 bytes) will underutilize the memory controller.
:::

## Deployment

### Bitstream Loading

Load your bitstream using Vivado Hardware Manager or Xilinx's runtime tools:

```bash
# Using Vivado Hardware Manager
vivado -mode tcl
open_hw_manager
connect_hw_server
open_hw_target
set_property PROGRAM.FILE {path/to/bitstream.bit} [get_hw_devices]
program_hw_devices [get_hw_devices]
```

### Runtime Setup

Build the Beethoven Runtime for the U200 (discrete FPGA) platform:

```bash
cd Beethoven-Runtime
mkdir build && cd build
cmake .. -DCMAKE_BUILD_TYPE=Release -DTARGET=fpga -DBACKEND=U200
make -j
sudo ./BeethovenRuntime
```

:::note Backend Support
U200 backend support may require platform-specific drivers and runtime modifications. Consult your U200 development kit documentation for PCIe driver setup.
:::

### Testbench Compilation

Your testbench compiles identically to other platforms:

```cmake title="CMakeLists.txt"
cmake_minimum_required(VERSION 3.30)
project(u200_test)

find_package(beethoven REQUIRED)
set(CMAKE_CXX_STANDARD 17)

beethoven_build(u200_test SOURCES test.cpp)
```

```bash
mkdir build && cd build
cmake ..
make -j
sudo ./u200_test
```

## Performance Optimization

### Clock Frequency

The default 300 MHz clock may not meet timing for complex designs. Try:
1. **Reduce clock**: Change `clockRateMHz` in `U200Platform` to 250 MHz or 200 MHz
2. **Add pipelining**: Use `RegNext()` on critical paths
3. **Optimize floorplanning**: Place related modules on the same SLR

### Memory Bandwidth

Maximize DDR4 utilization:
- Use burst transfers (large `len` values in reader/writer requests)
- Overlap computation with memory access
- Prefer sequential access patterns over random access

### Resource Utilization

Check per-SLR utilization in Vivado:
```tcl
report_utilization -hierarchical
```

Balance resource usage across SLRs using floorplanning constraints.

## Comparison with AWS F2

| Feature | U200 | AWS F2 |
|---------|------|--------|
| **FPGA** | VU+ (3 SLRs) | VU9P (3 SLRs) |
| **Memory** | 16GB DDR4 | 16GB DDR4 |
| **Clock** | 300 MHz | 250 MHz |
| **Interface** | 512-bit | 512-bit |
| **Shell Integration** | Manual | Automated |
| **Deployment** | On-premises | Cloud |
| **Cost** | Hardware purchase | Per-hour rental |

**When to use U200:**
- On-premises deployment
- Own hardware infrastructure
- Sensitive data that can't go to cloud

**When to use AWS F2:**
- Cloud-native workflows
- Don't want to manage hardware
- Automated build flow with AFI generation

## Troubleshooting

### Timing Failures

If implementation fails timing:
1. Check critical path in timing report
2. Identify SLR crossings (often bottlenecks on multi-die FPGAs)
3. Add pipeline stages or reduce clock frequency
4. Review [Floorplanning Guide](/docs/hardware/floorplanning) for optimization

### Resource Exhaustion

If synthesis fails with resource errors:
1. Check per-SLR utilization in Vivado
2. Move modules to less-utilized SLRs using `DeviceContext.withDevice()`
3. Reduce design size (fewer cores, smaller scratchpads)

### Memory Interface Issues

If memory accesses fail:
1. Verify alignment (addresses must align to 64 bytes)
2. Check shell integration (memory interface wiring)
3. Test with simulation first to isolate hardware from FPGA board issues

## See Also

- [AWS F2 Platform](/docs/platforms/aws-f2) - Similar 3-die platform with automated flow
- [Floorplanning Guide](/docs/hardware/floorplanning) - Multi-die optimization
- [Custom Platform](/docs/platforms/custom-platform) - Creating platform definitions
- [Memory Interfaces](/docs/hardware/memory) - Memory channel configuration
